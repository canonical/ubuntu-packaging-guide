import bisect
from collections.abc import Mapping
from enum import Enum
import json
from datetime import datetime


# use the same value for end of life date comparisons to avoid inconsistencies
now = datetime.now()


def WriteRstFileHeader(rstFile) -> None:
    rstFile.write("..\n")
    rstFile.write(" ******************************************************************************\n")
    rstFile.write(" * DO NOT EDIT THIS FILE! ANY CHANGES WILL BE OVERWRITTEN!                    *\n")
    rstFile.write(" *                                                                            *\n")
    rstFile.write(" * This file was generated by the generateReStructuredText.py script.         *\n")
    rstFile.write(" * - To add a new release or change the data of an existing release, edit the *\n")
    rstFile.write(" *   release-data.json file.                                                  *\n")
    rstFile.write(" * - To change the layout, edit the generateReStructuredText.py script that   *\n")
    rstFile.write(" *   generated this file.                                                     *\n")
    rstFile.write(" ******************************************************************************\n\n")

IndexHeader = """
Ubuntu releases
===============

.. toctree::
  :titlesonly:
  :reversed:
  :hidden:

"""

InDevelopmentRstHeader = """
In development
--------------

"""

InDevelopmentRstFooter = """

"""

InStandardSupportHeader = """
In standard support
-------------------

"""

InStandardSupportFooter = """

"""

InESMHeader = """
In Expanded Security Maintenance (ESM)
--------------------------------------

"""

InESMFooter = """

"""

InESMWithLegacyAddOnHeader = """
In Expanded Security Maintenance (ESM) with Legacy add-on
---------------------------------------------------------

"""

InESMWithLegacyAddOnFooter = """

"""

EOLHeader = """

"""
EOLFooter = """

"""

IndexFooter = """

"""


def GetDateString(date) -> str:
    return date.strftime('%B %-d, %Y')


class UbuntuReleaseSupportState(Enum):
    Unsupported = 0
    InDevelopment = 1
    StandardSupport = 2
    ExpandedSecurityMaintenance = 3
    ExpandedSecurityMaintenanceWithLegacyAddOn = 4
    EndOflife = 5


class UbuntuImageSource:
    def __init__(self, json) -> None:
        self.Name: str = json["name"]
        self.Href: str = json["href"]


class UbuntuSeries:
    def __init__(self, json) -> None:
        self.Version: str = json["version"]
        self.__SortingKey = int(self.Version.replace('.', ''))
        self.IsLts: bool = json["lts"]
        self.Codename: str = json["codename"]
        self.Series: str = self.Codename.lower().split(' ')[0]
        self.Href: str | None = json["href"] if "href" in json else None
        self.ReleaseSchedule = UbuntuReleaseSchedule(
            series=self,
            releaseSchedule=json["releaseSchedule"])
        self.SupportState = self.GetSupportState()
        self.Images: list[UbuntuImageSource] = []

        if "images" in json:
            for imageSource in json["images"]:
                self.Images.append(UbuntuImageSource(imageSource))

        
    def __str__(self) -> str:
        return self.ReleaseSchedule.FinalRelease.ReleaseName()
    

    def __eq__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey == value.__SortingKey


    def __ne__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey != value.__SortingKey


    def __ge__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey >= value.__SortingKey


    def __gt__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")

        return self.__SortingKey > value.__SortingKey


    def __le__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey <= value.__SortingKey


    def __lt__(self, value: object) -> bool:
        if not isinstance(value, UbuntuSeries): 
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey < value.__SortingKey


    def GetSupportState(self) -> UbuntuReleaseSupportState:        
        for event in self.ReleaseSchedule.Events:
            if event.Date <= now:
                continue
            
            if event.Type == "Final Release":
                return UbuntuReleaseSupportState.InDevelopment
            elif event.Type == "End of Standard Support":
                return UbuntuReleaseSupportState.StandardSupport
            elif event.Type == "End of Expanded Security Maintenance":
                return UbuntuReleaseSupportState.ExpandedSecurityMaintenance
            
        return UbuntuReleaseSupportState.EndOflife
                

    def ToReStructedText(self) -> str:
        links = {}

        rst = str(self)
        rst += "\n" + "~" * len(rst) + "\n"
        rst += "\n"
        
        rst = f".. _{self.Codename}:\n\n{rst}"

        rst += "Version:\n"
        rst += f"  {self.Version}\n\n"

        rst += "Type:\n"
        if self.IsLts:
            rst += "  :ref:`LTS release <LTSReleases>`\n\n"
        else:
            rst += "  :ref:`Interim release <InterimReleases>`\n\n"

        rst += "Codename:\n"
        rst += f"  {self.Codename}"
        if self.Href is not None:
            id = str(self) + " Ubuntu Wiki Entry"
            links[id] = (self.Href, "Ubuntu Wiki")
            rst += f" (|{id}|_)"
        rst += "\n\n"

        rst += "Series:\n"
        rst += f"  ``{self.Series}``\n\n"

        rst += "End of Standard Support:\n"
        for endOfStandardSupportEvent in self.ReleaseSchedule.EndOfStandardSupport:
            if endOfStandardSupportEvent.Component is not None:
                component = f"**{endOfStandardSupportEvent.Component}:** "
            else:
                component = ""

            if endOfStandardSupportEvent.Href is not None:
                id = str(self) + (" " + endOfStandardSupportEvent.Component
                        if endOfStandardSupportEvent.Component is not None
                        else "") + "  EoL Announcement"
                links[id] = (endOfStandardSupportEvent.Href, "EoL Announcement")
                link = f" (|{id}|_)"
            else:
                link = ""

            rst += f"  | {component}{endOfStandardSupportEvent.DateString()}{link}\n"
        rst += "\n"

        if self.ReleaseSchedule.EndOfExpandedSecurityMaintenance is not None:
            if self.ReleaseSchedule.EndOfExpandedSecurityMaintenance.Href is not None:
                id = str(self) + "  ESM EoL Announcement"
                links[id] = (self.ReleaseSchedule.EndOfExpandedSecurityMaintenance.Href, "EoL Announcement")
                link = f" (|{id}|_)"
            else:
                link = ""

            rst += "End of Expanded Security Maintenance (ESM):\n"
            rst += f"  | {self.ReleaseSchedule.EndOfExpandedSecurityMaintenance.DateString()}{link}\n"
            if self.ReleaseSchedule.EndOfLegacySupportAddOn is not None:
                if self.ReleaseSchedule.EndOfLegacySupportAddOn.Href is not None:
                    id = str(self) + "  ESM Legacy Announcement"
                    links[id] = (self.ReleaseSchedule.EndOfLegacySupportAddOn.Href, "Legacy support add-on")
                    rst += f"  | {self.ReleaseSchedule.EndOfLegacySupportAddOn.DateString()} (with |{id}|_)\n"
                else:
                    rst += f"  | {self.ReleaseSchedule.EndOfLegacySupportAddOn.DateString()} (with Legacy support add-on)\n"
            rst += "\n"
        
        if len(self.Images) > 0:
            rst += "Images:\n"
            for imageSource in self.Images:
                rst += f"  - {imageSource.Name}\n"
            rst += "\n"

        rst += f".. _{self.Codename} Releases:\n\n"
        rst += "Releases:\n"

        if len(self.ReleaseSchedule.HardwareEnablementEndOfLife) > 0:
            rst += "  .. important::\n\n"
            for hardwareEnablementEndOfLife in self.ReleaseSchedule.HardwareEnablementEndOfLife:
                rst += "    **The hardware enablement stack of the release"

                if len(hardwareEnablementEndOfLife.AffectedPointReleases) > 1:
                    rst += "s"

                rst += " " + ", ".join(map(
                    lambda pointReleaseNumber: self.Version + ("." + str(pointReleaseNumber) if pointReleaseNumber > 0 else ""), 
                    hardwareEnablementEndOfLife.AffectedPointReleases))
            
                if hardwareEnablementEndOfLife.Date <= now:
                    rst += "    were"
                else:
                    rst += "    will be"

                if hardwareEnablementEndOfLife.Href is not None:
                    id = str(self) + " " + hardwareEnablementEndOfLife.Type + " Announcement"
                    links[id] = (hardwareEnablementEndOfLife.Href, "Announcement")
                    link = f" (|{id}|_)"
                else:
                    link = ""

                rst += f" deprecated on {hardwareEnablementEndOfLife.DateString()}.**{link}\n\n"

        rst += "  .. list-table::\n"
        rst += "      :header-rows: 1\n\n"
        rst += f"      * - Version\n"
        rst += f"        - Release Date\n"
        rst += f"        - Documentation\n"
        
        releases = [x for x in self.ReleaseSchedule.Events if (isinstance(x, FinalRelease) or isinstance(x, PointRelease))]
        boldFirstRelease = len(releases) > 1
        for release in reversed(releases):
            if boldFirstRelease:
                rst += f"      * - **{release.ReleaseName()}**\n"
                boldFirstRelease = False
            else:
                rst += f"      * - {release.ReleaseName()}\n"

            rst += f"        - {release.DateString()}\n"
            
            linkCount = 0

            if release.Href is not None:
                id = release.ReleaseName() + " Announcement"
                links[id] = (release.Href, "Release Announcement")
                if linkCount == 0:
                    rst += "        - | "
                else:
                    rst += "          | "
                rst +=  f"|{id}|_\n"
                linkCount += 1
            
            if release.NotesHref is not None:
                id = release.ReleaseName() + " Notes"
                links[id] = (release.NotesHref, "Release Notes")
                if linkCount == 0:
                    rst += "        - | "
                else:
                    rst += "          | "
                rst +=  f"|{id}|_\n"
                linkCount += 1

            if linkCount == 0:
                rst += "        - \n"
        rst += "\n"

        rst +=  "Release Schedule:\n"
        rst +=  "  .. list-table::\n"
        rst +=  "      :header-rows: 1\n\n"
        rst += f"      * - Date\n"
        rst += f"        - Event\n"
        for event in self.ReleaseSchedule.Events:
            rst += f"      * - {event.DateString()}\n"
            if event.Href is not None:
                id = f"{self} {event.DisplayName()} Event Announcement"
                links[id] = (event.Href, "Announcement")
                link = f" (|{id}|_)"
            else:
                link = ""

            if event.Type == "Alpha Release" and event.AlphaReleaseNumber is not None:
                name = f":ref:`{event.Type} <{event.Type}>` {event.AlphaReleaseNumber}"
            elif event.Type == "Beta Release" and event.BetaReleaseNumber is not None:
                name = f":ref:`{event.Type} <{event.Type}>` {event.BetaReleaseNumber}"
            elif event.Type == "Point Release":
                name = f"{self.Version}.{event.PointReleaseNumber} :ref:`{event.Type} <{event.Type}>`"
            elif event.Type == "End of Standard Support" and event.Component is not None:
                name = f":ref:`{event.Type} <{event.Type}>` ({event.Component})"
            elif event.Type == "Hardware Enablement End of Life":
                affectedReleases=", ".join(map(lambda pointReleaseNumber: self.Version + "." + str(pointReleaseNumber), event.AffectedPointReleases))
                name = f":ref:`{event.Type} <{event.Type}>` for {affectedReleases}"
            else:
                name = f":ref:`{event.Type} <{event.Type}>`"

            rst += f"        - {name}{link}\n"
            
        rst += "\n"

        if self.ReleaseSchedule.Href is not None:
            id = str(self) + " Release Schedule"
            links[id] = (self.ReleaseSchedule.Href, "Release Schedule")
            rst += f"  For more detailed information see the original |{id}|_\n\n"
        rst += "\n"
        
        if len(links) > 0:

            for id, hrefAndDisplayName in links.items():
                rst += f".. _{id}: {hrefAndDisplayName[0]}\n"
                rst += f".. |{id}| replace:: {hrefAndDisplayName[1]} :octicon:`link-external`\n\n"
            
            rst += "\n"
        
        return rst


    def WriteToRstFile(self) -> str:
        fileName = f"ubuntu.{self.Version}.{self.Codename.lower().replace(' ', '-')}.rst"
        rst = self.ToReStructedText()

        with open(fileName, 'w') as rstFile:
            WriteRstFileHeader(rstFile)
            rstFile.write(rst)

        return fileName


class UbuntuReleaseSchedule:
    def __init__(self, series: UbuntuSeries, releaseSchedule) -> None:
        self.Href = releaseSchedule['href'] if 'href' in releaseSchedule else None
        self.Events: list['ReleaseEvent'] = []
        self.FinalRelease: FinalRelease = None
        self.PointReleases: list[PointRelease] = []
        self.EndOfStandardSupport: list['EndOfStandardSupport'] = []
        self.HardwareEnablementEndOfLife: list['HardwareEnablementEndOfLife'] = []
        self.EndOfExpandedSecurityMaintenance: ReleaseEvent | None = None
        self.EndOfLegacySupportAddOn: ReleaseEvent | None = None
        
        for event in releaseSchedule['events']:
            parsedEvent = ReleaseEvent.Parse(event, series)
            bisect.insort(self.Events, parsedEvent, key=lambda x: x.Date)

            if isinstance(parsedEvent, FinalRelease):
                self.FinalRelease = parsedEvent
            elif isinstance(parsedEvent, PointRelease):
                bisect.insort(self.PointReleases, parsedEvent, key=lambda x: x.Date)
            elif isinstance(parsedEvent, EndOfStandardSupport):
                bisect.insort(self.EndOfStandardSupport, parsedEvent, key=lambda x: x.Date)
            elif isinstance(parsedEvent, HardwareEnablementEndOfLife):
                bisect.insort(self.HardwareEnablementEndOfLife, parsedEvent, key=lambda x: x.Date)
            elif parsedEvent.Type == "End of Expanded Security Maintenance":
                self.EndOfExpandedSecurityMaintenance = parsedEvent
            elif parsedEvent.Type == "End of Legacy Support add-on":
                self.EndOfLegacySupportAddOn = parsedEvent


class ReleaseEvent:
    def __init__(self, type : str, date: datetime, href: str | None, series: UbuntuSeries) -> None:
        self.Type = type
        self.Date = date
        self.Href = href
        self.Series = series

    @staticmethod
    def Parse(releaseEvent, series: UbuntuSeries) -> 'ReleaseEvent':
        eventType = releaseEvent['type']
        eventDate = datetime.strptime(releaseEvent['date'], '%Y-%m-%d')
        eventHref = releaseEvent['href'] if 'href' in releaseEvent else None
        notesHref = releaseEvent['notes']['href'] if 'notes' in releaseEvent else None

        if eventType == "Alpha Release":
            alphaReleaseNumber = releaseEvent['alphaReleaseNumber'] if 'alphaReleaseNumber' in releaseEvent else None
            return AlphaRelease(eventDate, eventHref, notesHref, alphaReleaseNumber, series)
        elif eventType == "Beta Release":
            betaReleaseNumber = releaseEvent['betaReleaseNumber'] if 'betaReleaseNumber' in releaseEvent else None
            return BetaRelease(eventDate, eventHref, notesHref, betaReleaseNumber, series)
        elif eventType == "Final Release":
            return FinalRelease(eventDate, eventHref, notesHref, series)
        elif eventType == "Point Release":
            return PointRelease(eventDate, eventHref, notesHref, releaseEvent['pointReleaseNumber'], series)
        elif eventType == "Hardware Enablement End of Life":
            return HardwareEnablementEndOfLife(eventDate, eventHref, releaseEvent['affectedPointReleases'], series)
        elif eventType == "End of Standard Support":
            component=releaseEvent['component'] if 'component' in releaseEvent else None
            return EndOfStandardSupport(eventDate, eventHref, component, series)
        else:
            return ReleaseEvent(eventType, eventDate, eventHref, series)
        

    def DateString(self) -> str:
        return GetDateString(self.Date)

    def DisplayName(self) -> str:
        return self.Type
    

class UbuntuRelease(ReleaseEvent):
    def __init__(self, type : str, date: datetime, href: str | None, notesHref : str | None, series: UbuntuSeries) -> None:
        super().__init__(type, date, href, series)
        self.NotesHref = notesHref
        self.__SortingKey = series._UbuntuSeries__SortingKey * 1000
        # first digit = alpha release number
        # second digit = beta release number + 1
        # third digit = point release number + 1; 0 for alpha & beta release

    def ReleaseName(self, 
                    includeUbuntuPrefix: bool = True, 
                    includeCodeName: bool = True) -> str:
        raise NotImplemented()
    
    
    def GetHardwareEnablementEndOfLife(self) -> 'HardwareEnablementEndOfLife':
        if isinstance(self, FinalRelease):
            pointReleaseNumber = 0
        elif isinstance(self, PointRelease):
            pointReleaseNumber = self.PointReleaseNumber
        else:
            return None
        
        for heEoL in self.Series.ReleaseSchedule.HardwareEnablementEndOfLife:
            if pointReleaseNumber in heEoL.AffectedPointReleases:
                return heEoL
        
        return None


    def GetSupportState(self, newLinePrefix: str = "        ") -> tuple[UbuntuReleaseSupportState, str]:
        # NOTE: this implementation is certainly not the most performant, but it is readable
        
        # get end of support events
        eolComponents = []
        endOfStandardSupportEvents = self.Series.ReleaseSchedule.EndOfStandardSupport
        endOfExpandedSecurityMaintenanceEvent = self.Series.ReleaseSchedule.EndOfExpandedSecurityMaintenance
        endOfLegacySupportAddOnEvent = self.Series.ReleaseSchedule.EndOfLegacySupportAddOn
        eolDate = endOfStandardSupportEvents[0].Date

        # filter out all end of support events in the past
        buffer = []
        for event in endOfStandardSupportEvents:
            if event.Date > eolDate:
                eolDate = event.Date

            if event.Date > now:
                buffer.append(event)
            else:
                eolComponents.append(event)
        endOfStandardSupportEvents = buffer
        
        if endOfExpandedSecurityMaintenanceEvent is not None: 
            eolDate = endOfExpandedSecurityMaintenanceEvent.Date
            if endOfExpandedSecurityMaintenanceEvent.Date <= now:
                endOfExpandedSecurityMaintenanceEvent = None
        
            if endOfLegacySupportAddOnEvent is not None:
                eolDate = endOfLegacySupportAddOnEvent.Date
                if endOfLegacySupportAddOnEvent.Date <= now:
                    endOfLegacySupportAddOnEvent = None

        # filter out all end of support events past the hardware enablement end of life
        heEoL = self.GetHardwareEnablementEndOfLife()
        
        if heEoL is not None:
            if heEoL.Date <= now:
                rst  = f"| {heEoL.DateString()}\n"
                rst += f"{newLinePrefix}| (Hardware Enablement End of Life)\n"

                return UbuntuReleaseSupportState.EndOflife, rst
            
            endOfStandardSupportEvents = [event for event in endOfStandardSupportEvents if event.Date < heEoL.Date]
            buffer = []
            for event in endOfStandardSupportEvents:
                if event.Date < heEoL.Date:
                    buffer.append(event)
                else:
                    eolComponents.append(event)
            endOfStandardSupportEvents = buffer

            if (endOfExpandedSecurityMaintenanceEvent is not None
                and endOfExpandedSecurityMaintenanceEvent.Date >= heEoL.Date):
                endOfExpandedSecurityMaintenanceEvent = None
        
                if (endOfLegacySupportAddOnEvent is not None 
                    and endOfLegacySupportAddOnEvent.Date >= heEoL.Date):
                    endOfLegacySupportAddOnEvent = None

            eolDate = heEoL.Date
        
        # build support info rst string
        supportState = None
        rst = ""

        if eolDate <= now:
            if len(self.Series.ReleaseSchedule.EndOfStandardSupport) == 1:
                rst += f"| {GetDateString(eolDate)}\n"
                return UbuntuReleaseSupportState.EndOflife, rst
            else:
                firstLine = True
                for endOfStandardSupportEvent in self.Series.ReleaseSchedule.EndOfStandardSupport:
                    if firstLine:
                        firstLine = False
                    else:
                        rst += newLinePrefix

                    rst += f"| {endOfStandardSupportEvent.DateString()} ({endOfStandardSupportEvent.Component})\n"
                
                return UbuntuReleaseSupportState.EndOflife, rst + "\n"

        if len(endOfStandardSupportEvents) > 0:
            supportState = UbuntuReleaseSupportState.StandardSupport
            rst += "| **End of Standard Support:**\n"
            for endOfStandardSupportEvent in endOfStandardSupportEvents:
                component = (f" ({endOfStandardSupportEvent.Component})"
                             if endOfStandardSupportEvent.Component is not None
                             else "")
                
                rst += f"{newLinePrefix}| {endOfStandardSupportEvent.DateString()}{component}\n"
            
            if endOfExpandedSecurityMaintenanceEvent is not None:
                rst += f"{newLinePrefix}| \n{newLinePrefix}| **End of ESM:**\n"
                rst += f"{newLinePrefix}| {endOfExpandedSecurityMaintenanceEvent.DateString()}\n"
                
                if endOfLegacySupportAddOnEvent is not None:
                    rst += f"{newLinePrefix}| {endOfLegacySupportAddOnEvent.DateString()} (with Legacy support add-on)\n"
        elif endOfExpandedSecurityMaintenanceEvent is not None:
            supportState = UbuntuReleaseSupportState.ExpandedSecurityMaintenance
            if len(rst) > 0:
                rst += f"{newLinePrefix}| \n{newLinePrefix}"
            rst += f"| {endOfExpandedSecurityMaintenanceEvent.DateString()}\n"

            if endOfLegacySupportAddOnEvent is not None:
                rst += f"{newLinePrefix}| {endOfLegacySupportAddOnEvent.DateString()} (with Legacy support add-on)\n"
        elif endOfLegacySupportAddOnEvent is not None:      
            supportState = UbuntuReleaseSupportState.ExpandedSecurityMaintenanceWithLegacyAddOn
            if len(rst) > 0:
                rst += f"{newLinePrefix}| \n{newLinePrefix}"
            rst += f"| {endOfLegacySupportAddOnEvent.DateString()}\n"

        if heEoL is not None:
            if len(rst) > 0:
                rst += f"{newLinePrefix}| \n{newLinePrefix}"
            rst += "| **Hardware Enablement End Of Life:**\n"
            rst += f"{newLinePrefix}| {heEoL.DateString()}\n"

        if self.Date > now:
            return UbuntuReleaseSupportState.InDevelopment, rst

        if supportState is None:
            print("DEBUG: " + str(self.ReleaseName()))
            raise Exception("This state should be unreachable if the semantics of the parsed data are correct.")

        return supportState, rst
    

    def __eq__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey == value.__SortingKey


    def __ne__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey != value.__SortingKey


    def __ge__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey >= value.__SortingKey


    def __gt__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")

        return self.__SortingKey > value.__SortingKey


    def __le__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease):
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey <= value.__SortingKey


    def __lt__(self, value: object) -> bool:
        if not isinstance(value, UbuntuRelease): 
            raise TypeError(f"Can not compare type {type(value)} with {type(self)}")
        
        return self.__SortingKey < value.__SortingKey


class AlphaRelease(UbuntuRelease):
    def __init__(self, date: datetime, href: str | None, notesHref : str | None, alphaReleaseNumber : int | None, series: UbuntuSeries) -> None:
        super().__init__("Alpha Release", date, href, notesHref, series)
        self.AlphaReleaseNumber = alphaReleaseNumber
        if alphaReleaseNumber is not None:
            self._UbuntuRelease__SortingKey += self.AlphaReleaseNumber

    def ReleaseName(self, 
                    includeUbuntuPrefix: bool = True, 
                    includeCodeName: bool = True) -> str:
        version = ""
        
        if includeUbuntuPrefix:
            version = "Ubuntu "
        
        version += self.Series.Version

        if self.Series.IsLts:
            version += " LTS"
        
        version += " Alpha"

        if self.AlphaReleaseNumber is not None:
            version += " " + str(self.AlphaReleaseNumber)

        if includeCodeName:
            version += f" ({self.Series.Codename})"

        return version
    
    
    def DisplayName(self) -> str:
        if self.AlphaReleaseNumber is None:
            return self.Type
        else:
            return f"Alpha {self.AlphaReleaseNumber} Release"


    def GetSupportState(self, newLinePrefix: str) -> tuple[UbuntuReleaseSupportState, str]:
        return UbuntuReleaseSupportState.Unsupported, "Unsupported"


class BetaRelease(UbuntuRelease):
    def __init__(self, date: datetime, href: str | None, notesHref : str | None, betaReleaseNumber : int | None, series: UbuntuSeries) -> None:
        super().__init__("Beta Release", date, href, notesHref, series)
        self.BetaReleaseNumber = betaReleaseNumber
        if betaReleaseNumber is not None:
            self._UbuntuRelease__SortingKey += self.BetaReleaseNumber * 10
        self._UbuntuRelease__SortingKey += 10

    def ReleaseName(self, 
                    includeUbuntuPrefix: bool = True, 
                    includeCodeName: bool = True) -> str:
        version = ""
        
        if includeUbuntuPrefix:
            version = "Ubuntu "
        
        version += self.Series.Version

        if self.Series.IsLts:
            version += " LTS"
        
        version += " Beta"

        if self.BetaReleaseNumber is not None:
            version += " " + str(self.BetaReleaseNumber)

        if includeCodeName:
            version += f" ({self.Series.Codename})"

        return version


    def DisplayName(self) -> str:
        if self.BetaReleaseNumber is None:
            return self.Type
        else:
            return f"Beta {self.BetaReleaseNumber} Release"


    def GetSupportState(self, newLinePrefix: str) -> tuple[UbuntuReleaseSupportState, str]:
        return UbuntuReleaseSupportState.Unsupported, "Unsupported"
    

class FinalRelease(UbuntuRelease):
    def __init__(self, date: datetime, href: str | None, notesHref : str | None, version: UbuntuSeries) -> None:
        super().__init__("Final Release", date, href, notesHref, version)
        self._UbuntuRelease__SortingKey += 100


    def ReleaseName(self, 
                    includeUbuntuPrefix: bool = True, 
                    includeCodeName: bool = True) -> str:
        version = ""
        
        if includeUbuntuPrefix:
            version = "Ubuntu "
        
        version += self.Series.Version

        if self.Series.IsLts:
            version += " LTS"

        if includeCodeName:
            version += f" ({self.Series.Codename})"

        return version
    

class PointRelease(UbuntuRelease):
    def __init__(self, date: datetime, href: str | None, notesHref : str | None, pointReleaseNumber : int, series: UbuntuSeries) -> None:
        super().__init__("Point Release", date, href, notesHref, series)
        self.PointReleaseNumber = pointReleaseNumber
        self._UbuntuRelease__SortingKey += 100 * (pointReleaseNumber + 1)


    def ReleaseName(self, 
                    includeUbuntuPrefix: bool = True, 
                    includeCodeName: bool = True) -> str:
        version = ""
        
        if includeUbuntuPrefix:
            version = "Ubuntu "
        
        version += f"{self.Series.Version}.{self.PointReleaseNumber}" 

        if self.Series.IsLts:
            version += " LTS"
        
        if includeCodeName:
            version += f" ({self.Series.Codename})"

        return version
    

    def DisplayName(self) -> str:
        return f"{self.Series.Version}.{self.PointReleaseNumber} Point Release"


class EndOfStandardSupport(ReleaseEvent):
    def __init__(self, date: datetime, href: str | None, component: str | None, series: UbuntuSeries) -> None:
        ReleaseEvent.__init__(self, "End of Standard Support", date, href, series)
        self.Component = component

    def DisplayName(self) -> str:
        if self.Component is None:
            return self.Type
        else:
            return f"{self.Type} ({self.Component})"


class HardwareEnablementEndOfLife(ReleaseEvent):
    def __init__(self, date: datetime, href: str | None, affectedPointReleases: list[int], series: UbuntuSeries) -> None:
        ReleaseEvent.__init__(self, "Hardware Enablement End of Life", date, href, series)
        self.AffectedPointReleases = affectedPointReleases
    
    def DisplayName(self) -> str:
        return "Hardware Enablement End of Life for " + ", ".join(map(lambda pointReleaseNumber: self.Series.Version + "." + str(pointReleaseNumber), self.AffectedPointReleases))


def InsertReleases(series: UbuntuSeries, releasesBySupportState: Mapping[UbuntuReleaseSupportState, list[(FinalRelease | PointRelease, str)]]) -> None:
    supportState, text = series.ReleaseSchedule.FinalRelease.GetSupportState()
    bisect.insort(releasesBySupportState[supportState], (series.ReleaseSchedule.FinalRelease, text))

    for pointRelease in series.ReleaseSchedule.PointReleases:
        supportState, rst = pointRelease.GetSupportState()
        bisect.insort(releasesBySupportState[supportState], (pointRelease, rst))


def Main():
    with (open('./release-data.json', 'r') as ubuntuReleaseDataJsonFile, 
         open('./index.rst', 'w') as rstIndexFile):
        
        ubuntuSeriesesJson = json.load(ubuntuReleaseDataJsonFile)
        WriteRstFileHeader(rstIndexFile)

        releasesBySupportState: Mapping[UbuntuReleaseSupportState, list[(FinalRelease | PointRelease, str)]] = {
            UbuntuReleaseSupportState.InDevelopment: [],
            UbuntuReleaseSupportState.StandardSupport: [],
            UbuntuReleaseSupportState.ExpandedSecurityMaintenance: [],
            UbuntuReleaseSupportState.ExpandedSecurityMaintenanceWithLegacyAddOn: [],
            UbuntuReleaseSupportState.EndOflife: []
        }

        rstIndexFile.write(IndexHeader)

        for ubuntuSeriesJson in ubuntuSeriesesJson["series"]:
            series = UbuntuSeries(ubuntuSeriesJson)
            fileName = series.WriteToRstFile()
            rstIndexFile.write(f"  {fileName}\n")
            InsertReleases(series, releasesBySupportState)
        rstIndexFile.write("\n")    

        # In development
        rstIndexFile.write(InDevelopmentRstHeader)
        rstIndexFile.write("\n")

        rstIndexFile.write(".. list-table::\n")
        rstIndexFile.write("    :header-rows: 1\n\n")
        rstIndexFile.write(f"    * - Version\n")
        rstIndexFile.write(f"      - Codename\n")
        rstIndexFile.write(f"      - Release Date\n")
        rstIndexFile.write(f"      - Support\n")

        for entry in reversed(releasesBySupportState[UbuntuReleaseSupportState.InDevelopment]):    
            release: UbuntuRelease = entry[0]
            rst: str = entry[1]
            
            rstIndexFile.write(f"    * - :ref:`{release.ReleaseName(includeCodeName=False)} <{release.Series.Codename} Releases>`\n")
            rstIndexFile.write(f"      - :ref:`{release.Series.Codename} <{release.Series.Codename}>`\n")
            rstIndexFile.write(f"      - {release.DateString()}\n")
            rstIndexFile.write(f"      - {rst}")

        rstIndexFile.write("\n")
        rstIndexFile.write(InDevelopmentRstFooter)
        rstIndexFile.write("\n")

        # In standard support
        rstIndexFile.write(InStandardSupportHeader)
        rstIndexFile.write("\n")

        rstIndexFile.write(".. list-table::\n")
        rstIndexFile.write("    :header-rows: 1\n\n")
        rstIndexFile.write(f"    * - Version\n")
        rstIndexFile.write(f"      - Codename\n")
        rstIndexFile.write(f"      - Release Date\n")
        rstIndexFile.write(f"      - Support\n")
        
        for entry in reversed(releasesBySupportState[UbuntuReleaseSupportState.StandardSupport]):    #sorted(releasesBySupportState[UbuntuReleaseSupportState.StandardSupport], key=lambda x: x[0].ReleaseName(), reverse=True):
            release: UbuntuRelease = entry[0]
            rst: str = entry[1]

            rstIndexFile.write(f"    * - :ref:`{release.ReleaseName(includeCodeName=False)} <{release.Series.Codename} Releases>`\n")
            rstIndexFile.write(f"      - :ref:`{release.Series.Codename} <{release.Series.Codename}>`\n")
            rstIndexFile.write(f"      - {release.DateString()}\n")
            rstIndexFile.write(f"      - {rst}")

        rstIndexFile.write("\n")
        rstIndexFile.write(InStandardSupportFooter)
        rstIndexFile.write("\n")

        # In Expanded Security Maintenance (ESM)
        rstIndexFile.write(InESMHeader)
        rstIndexFile.write("\n")

        rstIndexFile.write(".. list-table::\n")
        rstIndexFile.write("    :header-rows: 1\n\n")
        rstIndexFile.write(f"    * - Version\n")
        rstIndexFile.write(f"      - Codename\n")
        rstIndexFile.write(f"      - Release Date\n")
        rstIndexFile.write(f"      - | End of ESM\n")

        for entry in reversed(releasesBySupportState[UbuntuReleaseSupportState.ExpandedSecurityMaintenance]):    
            release: UbuntuRelease = entry[0]
            rst: str = entry[1]

            rstIndexFile.write(f"    * - :ref:`{release.ReleaseName(includeCodeName=False)} <{release.Series.Codename} Releases>`\n")
            rstIndexFile.write(f"      - :ref:`{release.Series.Codename} <{release.Series.Codename}>`\n")
            rstIndexFile.write(f"      - {release.DateString()}\n")
            rstIndexFile.write(f"      - {rst}")

        rstIndexFile.write("\n")
        rstIndexFile.write(InESMFooter)
        rstIndexFile.write("\n")

        # In Expanded Security Maintenance (ESM) with Legacy add-on
        rstIndexFile.write(InESMWithLegacyAddOnHeader)
        rstIndexFile.write("\n")

        rstIndexFile.write(".. list-table::\n")
        rstIndexFile.write("    :header-rows: 1\n\n")
        rstIndexFile.write(f"    * - Version\n")
        rstIndexFile.write(f"      - Codename\n")
        rstIndexFile.write(f"      - Release Date\n")
        rstIndexFile.write(f"      - | End of ESM with\n")
        rstIndexFile.write(f"        | Legacy support add-on\n")

        for entry in reversed(releasesBySupportState[UbuntuReleaseSupportState.ExpandedSecurityMaintenanceWithLegacyAddOn]):    
            release: UbuntuRelease = entry[0]
            rst: str = entry[1]

            rstIndexFile.write(f"    * - :ref:`{release.ReleaseName(includeCodeName=False)} <{release.Series.Codename} Releases>`\n")
            rstIndexFile.write(f"      - :ref:`{release.Series.Codename} <{release.Series.Codename}>`\n")
            rstIndexFile.write(f"      - {release.DateString()}\n")
            rstIndexFile.write(f"      - {rst}")

        rstIndexFile.write("\n")
        rstIndexFile.write(InESMWithLegacyAddOnFooter)
        rstIndexFile.write("\n")

        rstIndexFile.write("\n\nEnd of Life\n-----------\n\n")
        rstIndexFile.write(EOLHeader)
        rstIndexFile.write("\n")

        rstIndexFile.write(".. list-table::\n")
        rstIndexFile.write("    :header-rows: 1\n\n")
        rstIndexFile.write(f"    * - Version\n")
        rstIndexFile.write(f"      - Codename\n")
        rstIndexFile.write(f"      - Release Date\n")
        rstIndexFile.write(f"      - End of Life\n")

        for entry in reversed(releasesBySupportState[UbuntuReleaseSupportState.EndOflife]):    
            release: UbuntuRelease = entry[0]
            rst = entry[1]

            rstIndexFile.write(f"    * - :ref:`{release.ReleaseName(includeCodeName=False)} <{release.Series.Codename} Releases>`\n")
            rstIndexFile.write(f"      - :ref:`{release.Series.Codename} <{release.Series.Codename}>`\n")
            rstIndexFile.write(f"      - {release.DateString()}\n")
            rstIndexFile.write(f"      - {rst}")

        rstIndexFile.write("\n")
        rstIndexFile.write(EOLFooter)
        rstIndexFile.write("\n")
        rstIndexFile.write(IndexFooter)
        rstIndexFile.write("\n")
        
                    
if __name__ == "__main__":
    Main()
